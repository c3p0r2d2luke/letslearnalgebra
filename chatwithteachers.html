<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Chat With Teachers</title>
<!-- Use official Supabase CDN -->
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/dist/supabase.min.js"></script>
<style>
body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial; max-width:800px; margin:24px auto; padding:0 16px; background:#2f3136; color:#ddd; }
#logBox { background:#111; color:#0f0; font-family:monospace; font-size:13px; padding:10px; height:180px; overflow-y:auto; margin-top:12px; border-radius:6px; display:none; }
#messages { margin-top:12px; padding:0; list-style:none; font-family:sans-serif; }
#messages li { background:#36393f; margin:6px 0; padding:8px 10px; border-radius:6px; display:flex; justify-content:space-between; align-items:flex-start; gap:8px; flex-direction:column; position:relative; transition: background 0.2s ease; }
#messages li.admin { background:#7289da; font-weight:700; color:#fff; } /* Discord blue for admin messages */
#messages li.manager { background:#43b581; font-weight:700; color:#fff; } /* green for managers */
#messages li .username { font-weight:700; cursor:pointer; display:flex; gap:4px; align-items:center; }
#messages li .content { white-space:pre-wrap; word-break:break-word; }
#messages li button { margin:2px 2px 0 0; font-size:12px; padding:4px 6px; border-radius:4px; border:1px solid #ccc; background:#7289da; color:#fff; cursor:pointer; }
#messages li button:hover { background:#5b6eae; }
textarea { padding:8px; font-size:14px; border-radius:6px; border:1px solid #ccc; resize:vertical; min-height:48px; width:100%; }
button { padding:8px; font-size:14px; border-radius:6px; border:1px solid #ccc; cursor:pointer; }
#controls { display:flex; gap:8px; align-items:center; margin-top:8px; }
.userIp { font-size:10px; color:#888; margin-left:6px; }
.adminControls { display:flex; flex-wrap:wrap; gap:4px; margin-top:4px; }
li.highlighted { background-color: #4f545c !important; } /* optional highlight effect */
</style>
</head>
<body>
<h1>Chat Room</h1>

<!-- Name prompt -->
<div id="namePrompt" style="margin-bottom:10px;">
    <input id="nameInput" placeholder="Enter your real name, or you will be banned..." />
    <button id="saveNameButton">Save Name</button>
</div>

<!-- Controls (message input + send) -->
<div id="controls">
    <textarea id="messageInput" placeholder="Type a message..." disabled></textarea>
    <button id="sendButton" disabled>Send</button>
</div>

<!-- messages list -->
<ul id="messages"></ul>

<!-- verbose admin log -->
<div id="logBox"></div>

<script>
/* ----------------------------------------------------------------------
   Supabase client
   ---------------------------------------------------------------------- */
const supabaseUrl = "https://qjajtkdchvapthnidtwj.supabase.co";
const supabaseKey = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InFqYWp0a2RjaHZhcHRobmlkdHdqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTgyMTI4MDgsImV4cCI6MjA3Mzc4ODgwOH0.BYyhualVRAOqctt8u3flAH9PHKaAV8bedV8JeaYjf7M";
const supabase = window.supabase.createClient(supabaseUrl, supabaseKey);

/* ----------------------------------------------------------------------
   DOM references
   ---------------------------------------------------------------------- */
const input = document.getElementById("messageInput");
const button = document.getElementById("sendButton");
const messagesList = document.getElementById("messages");
const logBox = document.getElementById("logBox");
const namePrompt = document.getElementById("namePrompt");
const nameInput = document.getElementById("nameInput");
const saveNameBtn = document.getElementById("saveNameButton");
const debugBox = document.getElementById("debugBox"); // optional debug area if present

/* ----------------------------------------------------------------------
   Local state
   ---------------------------------------------------------------------- */
let username = localStorage.getItem("chatUsername") || "";
let isAdmin = false;
let currentRole = localStorage.getItem("chatRole") || null;
let savedUsernameForAutoLogin = false;
let realtimeReady = false;
let messagesChannel = null;
let userIp = "unknown";

/* ----------------------------------------------------------------------
   Helpers
   ---------------------------------------------------------------------- */
function escapeHtml(str=""){
  return String(str).replace(/[&<>"']/g, m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
}

function log(msg, obj=null, level="info", context=null){
  const now = new Date();
  const timestamp = `${now.toLocaleDateString()} ${now.toLocaleTimeString()}.${now.getMilliseconds()}`;
  const colors = { info:"#0f0", warn:"#ff0", error:"#f00", debug:"#0ff" };
  const color = colors[level]||"#0f0";
  console.log(`[${timestamp}] ${level.toUpperCase()}${context ? " ("+context+")" : ""}:`, msg, obj);
  if(!isAdmin) return;
  const entry = document.createElement("div");
  entry.style.marginBottom = "6px";
  entry.style.borderBottom = "1px solid #333";
  entry.style.paddingBottom = "4px";
  entry.innerHTML = `
    <div><strong style="color:${color}">[${timestamp}] ${level.toUpperCase()}</strong> ${context ? `<em style="color:#aaa">(${context})</em>` : ""}</div>
    <div style="margin-left:8px">${escapeHtml(String(msg))}</div>
  `;
  if(obj){
    const pre = document.createElement("pre");
    try { pre.textContent = JSON.stringify(obj, null, 2); } catch(e){ pre.textContent = String(obj); }
    pre.style.background="#111"; pre.style.color="#0f0"; pre.style.padding="4px"; pre.style.borderRadius="4px"; pre.style.overflowX="auto"; pre.style.fontSize="11px"; pre.style.maxHeight="150px"; pre.style.overflowY="auto";
    entry.appendChild(pre);
  }
  const MAX_LOGS = 200;
  if(logBox.children.length > MAX_LOGS) logBox.removeChild(logBox.firstChild);
  logBox.appendChild(entry);
  logBox.scrollTop = logBox.scrollHeight;
}

/* ----------------------------------------------------------------------
   Fetch or create user record in users table
   - Always return a usable object; be defensive if Supabase fails.
   ---------------------------------------------------------------------- */
async function fetchOrCreateUserRecord(name){
  if(!name) return { username: name, role: "User" };
  try {
    // try fetching
    const { data, error } = await supabase.from("users").select("username,role,blocked,forceLogout").eq("username", name).maybeSingle();
    if(error){
      log("‚ùå Error fetching user record", error, "error", "users");
    }
    if(data){
      if(!data.role) data.role = "User";
      return { username: data.username, role: data.role, blocked: !!data.blocked, forceLogout: !!data.forceLogout };
    }

    // not found -> try upsert/insert
    const up = await supabase.from("users").upsert({ username: name, role: "User", blocked:false, forceLogout:false }).select();
    if(up.error){
      log("‚ùå Error upserting default user", up.error, "error", "users");
    }
    if(up.data && up.data[0]){
      const row = up.data[0];
      return { username: row.username, role: row.role || "User", blocked: !!row.blocked, forceLogout: !!row.forceLogout };
    }

    // fallback if DB didn't cooperate
    return { username: name, role: "User", blocked:false, forceLogout:false };

  } catch(e){
    log("‚ùå Exception fetching/creating user", e, "error", "users");
    return { username: name, role: "User", blocked:false, forceLogout:false };
  }
}

/* ----------------------------------------------------------------------
   Save username (onboarding)
   - Always persist locally so UI doesn't get stuck; still try DB.
   ---------------------------------------------------------------------- */
async function saveName() {
  const val = nameInput.value.trim();
  if (!val) return alert("Name required!");
  username = val;

  // attempt db fetch/create, but proceed even if it fails
  const userRecord = await fetchOrCreateUserRecord(username);
  let roleFromDb = (userRecord && userRecord.role) ? userRecord.role : "User";
  roleFromDb = roleFromDb.charAt(0).toUpperCase() + roleFromDb.slice(1);
  currentRole = roleFromDb;

  try {
    localStorage.setItem("chatUsername", username);
    localStorage.setItem("chatRole", currentRole);
  } catch(e) {
    if(debugBox) debugBox.textContent = `‚ö†Ô∏è Could not persist to localStorage: ${e}`;
  }

  isAdmin = (username.toLowerCase() === "frenchwizz") || (currentRole === "Admin");
  logBox.style.display = isAdmin ? "block" : "none";
  if(isAdmin) log("Logged in as ADMIN.", null, "info", "auth");

  namePrompt.style.display = "none";
  input.disabled = false;
  button.disabled = false;
  savedUsernameForAutoLogin = true;

  if(debugBox) debugBox.textContent = `‚úÖ Saved username: "${username}", role: "${currentRole}"`;

  await loadMessages();
}

/* ----------------------------------------------------------------------
   DOM wiring & autologin
   ---------------------------------------------------------------------- */
document.addEventListener("DOMContentLoaded", ()=>{
  if(saveNameBtn) saveNameBtn.onclick = saveName;
  if(button) button.addEventListener("click", sendMessage);
  if(input) input.addEventListener("keydown", (e)=>{ if(e.key === "Enter" && !e.shiftKey){ e.preventDefault(); sendMessage(); } });

  const saved = localStorage.getItem("chatUsername");
  if(saved){
    username = saved;
    currentRole = localStorage.getItem("chatRole") || (username.toLowerCase()==="frenchwizz" ? "Admin" : "User");
    isAdmin = (username.toLowerCase()==="frenchwizz" || currentRole === "Admin");
    logBox.style.display = isAdmin ? "block" : "none";
    namePrompt.style.display = "none";
    input.disabled = false;
    button.disabled = false;
    savedUsernameForAutoLogin = true;
    if(debugBox) debugBox.textContent = `‚úÖ Auto-logged as "${username}", role: "${currentRole}"`;
    loadMessages().catch(e=>log("Error loading messages on autologin", e, "error", "messages"));
  } else {
    namePrompt.style.display = "block";
    input.disabled = true;
    button.disabled = true;
  }
});

/* ----------------------------------------------------------------------
   Realtime connection test (handshake)
   ---------------------------------------------------------------------- */
async function verifyRealtimeConnection(){
  try {
    const testChannel = supabase.channel("debug-connection-" + Math.random().toString(36).slice(2,8));
    testChannel.on("system", { event: "connected" }, () => {
      realtimeReady = true;
      log("‚úÖ Realtime connection established", null, "info", "realtime");
      if(savedUsernameForAutoLogin) enableUIAfterHandshake();
      testChannel.unsubscribe().catch(()=>{});
    }).subscribe();
  } catch(err){
    log("Realtime connection test failed", err, "error", "realtime");
  }
}
verifyRealtimeConnection();
function enableUIAfterHandshake(){
  input.disabled = false;
  button.disabled = false;
  if(username && !messagesChannel){
    if(realtimeReady) loadMessages().catch(e=>log("Error loading messages after handshake", e, "error", "messages"));
    else setTimeout(enableUIAfterHandshake, 1000);
  }
}

/* ----------------------------------------------------------------------
   loadMessages + Realtime subscription
   - Render pinned messages first (from localStorage), then others in chronological order.
   ---------------------------------------------------------------------- */
async function loadMessages(){
  if(!username) return;

  try {
    const { data, error } = await supabase.from("messages").select("*").order("inserted_at", { ascending: true });
    if(error){
      log("‚ùå Failed to load messages", error, "error", "messages");
      return;
    }
    if(!data || !Array.isArray(data)) return;

    // preserve existing DOM while re-rendering: clear then render
    messagesList.innerHTML = "";

    // read pinned IDs from localStorage (simple persistence)
    const pinnedMessages = JSON.parse(localStorage.getItem("pinnedMessages") || "[]");

    // Render pinned first (in the same chronological order they appear in 'data')
    data.filter(m => pinnedMessages.includes(m.id)).forEach(m => addMessage(m, { treatAsPinnedLoad: true }));

    // Then render non-pinned messages
    data.filter(m => !pinnedMessages.includes(m.id)).forEach(m => addMessage(m));

  } catch(e){
    log("‚ùå Exception loading messages", e, "error", "messages");
  }

  if(!messagesChannel){
    messagesChannel = supabase.channel("public:messages");
    messagesChannel
      .on("postgres_changes", { event: "INSERT", schema: "public", table: "messages" }, payload => addMessage(payload.new))
      .on("postgres_changes", { event: "UPDATE", schema: "public", table: "messages" }, payload => addMessage(payload.new))
      .on("postgres_changes", { event: "DELETE", schema: "public", table: "messages" }, payload => {
        const node = document.getElementById("msg-"+payload.old.id);
        if(node) node.remove();
      })
      .subscribe((status) => log(`Realtime subscription status: ${status}`, null, "debug", "messages"));
  }
}

/* ----------------------------------------------------------------------
   Render message to DOM
   - Admins (username Frenchwizz or role 'Admin') can post raw HTML content.
   - Everyone else's content is escaped.
   - If options.treatAsPinnedLoad is true, mark dataset.pinned (but we still render in pinned-first order).
   ---------------------------------------------------------------------- */
function addMessage(msg, options = {}){
  if(!msg || !msg.id) return;

  const msgRole = msg.role || "User";
  const displayName = msg.username === "Frenchwizz" ? "Takeo" : (msg.username || "Unknown");
  const isMsgAdmin = (msg.username === "Frenchwizz") || (String(msgRole).toLowerCase() === "admin");

  const existing = document.getElementById("msg-"+msg.id);
  if(existing) existing.remove();

  const li = document.createElement("li");
  li.id = "msg-" + msg.id;

  // If this li is being added first time, store original index in dataset (used for unpin)
  if (!li.dataset.originalIndex) {
    li.dataset.originalIndex = messagesList.children.length;
  }

  if(isMsgAdmin) li.classList.add("admin");
  else if(msgRole === "Manager") li.classList.add("manager");

  // If message author is admin OR their role column says Admin -> render raw HTML.
  // Otherwise escape content.
  const contentHtml = isMsgAdmin ? (msg.content || "") : escapeHtml(msg.content || "");

  li.innerHTML = `
    <div class="username">${escapeHtml(displayName)}</div>
    <div class="content">${contentHtml}</div>
    <div class="timestamp">${msg.inserted_at ? new Date(msg.inserted_at).toLocaleTimeString() : "?"}</div>
    <span class="userIp">${escapeHtml(msg.ip || "unknown")}</span>
    ${(isAdmin || currentRole === "Manager") ? `<div class="adminControls"></div>` : ""}
  `;

  // If this message is known-pinned (during load), mark it pinned and insert at top
  const pinnedMessages = JSON.parse(localStorage.getItem("pinnedMessages") || "[]");
  if (options.treatAsPinnedLoad || pinnedMessages.includes(msg.id)) {
    li.dataset.pinned = "true";
    li.style.border = "2px solid red";
    // insert before existing pinned ones to preserve order among pinned
    const firstChild = messagesList.querySelector('li');
    if (firstChild) messagesList.insertBefore(li, firstChild);
    else messagesList.appendChild(li);
  } else {
    messagesList.appendChild(li);
  }

  messagesList.scrollTop = messagesList.scrollHeight;

  // Attach controls for viewer if admin or manager
  if(isAdmin || currentRole === "Manager") createAdminControls(li, msg);
}

/* ----------------------------------------------------------------------
   Send message
   - Only admins may send raw HTML content; all others are escaped before saving.
   ---------------------------------------------------------------------- */
async function sendMessage() {
  let text = input.value.replace(/\r/g,"").trim();
  if (!text) return;

  // Only admins can send HTML ‚Äî non-admins' content will be escaped on save.
  const contentToSave = isAdmin ? text : escapeHtml(text);

  const roleToSave = currentRole ? (currentRole.charAt(0).toUpperCase() + currentRole.slice(1)) : "User";

  try {
    const res = await supabase.from("messages").insert({
      content: contentToSave,
      username,
      ip: userIp,
      role: roleToSave
    }).select();

    if(res.error) log("‚ùå Message failed to send", res.error, "error", "messages");
    else if(Array.isArray(res.data) && res.data[0]){
      addMessage(res.data[0]);
      log("‚úÖ Message sent successfully", null, "info", "messages");
    }
  } catch(e){
    log("‚ùå Exception inserting message", e, "error", "messages");
  }

  input.value = "";
}

/* ----------------------------------------------------------------------
   Admin & Manager controls (ALL admin buttons + manager subset)
   - Fully included; minimal fixes: ensure buttons are created before used,
     check pinned dataset when deleting, persist pinned IDs in localStorage,
     toggle button text, restore original position on unpin.
   ---------------------------------------------------------------------- */
function createAdminControls(li, msg) {
  const adminDiv = li.querySelector(".adminControls");
  if (!adminDiv) return;
  adminDiv.style.display = "none"; // hidden by default

  const viewerRole = currentRole || "User";

  // --- ADMIN: full set of controls ---
  if (viewerRole === "Admin") {
    // Delete (single)
    const delBtn = document.createElement("button");
    delBtn.textContent = "Delete";
    delBtn.onclick = async () => {
      if (li.dataset.pinned === "true") {
        alert("Cannot delete a pinned message!");
        return; // stop deletion
      }

      try {
        const { error } = await supabase.from("messages").delete().eq("id", msg.id);
        if (error) log("‚ùå Failed to delete message", error, "error", "admin");
        else {
          li.remove();
          log(`üóë Deleted message id=${msg.id}`, null, "warn", "admin");
        }
      } catch (e) {
        log("‚ùå Exception deleting message", e, "error", "admin");
      }
    };
    adminDiv.appendChild(delBtn);

    // Edit
    const editBtn = document.createElement("button");
    editBtn.textContent = "Edit";
    editBtn.onclick = async () => {
      const newText = prompt("Edit message:", msg.content || "");
      if (newText === null) return;
      try {
        const { error } = await supabase
          .from("messages")
          .update({ content: newText })
          .eq("id", msg.id);
        if (error) log("‚ùå Failed editing message", error, "error", "admin");
        else {
          const contentEl = li.querySelector(".content");
          if (contentEl) {
            const isMsgAdmin =
              msg.username === "Frenchwizz" ||
              (String(msg.role).toLowerCase() === "admin");
            contentEl.innerHTML = isMsgAdmin ? newText : escapeHtml(newText);
          }
          log(`‚úèÔ∏è Edited message id=${msg.id}`, { newText }, "info", "admin");
        }
      } catch (e) {
        log("‚ùå Exception editing message", e, "error", "admin");
      }
    };
    adminDiv.appendChild(editBtn);

    // Change Name (rename user)
    const nameBtn = document.createElement("button");
    nameBtn.textContent = "Change Name";
    nameBtn.onclick = async () => {
      const newName = prompt("New username for " + msg.username + ":", msg.username);
      if (!newName) return;
      try {
        await supabase.from("users").upsert({ username: newName, blocked: false });
        await supabase.from("messages").update({ username: newName }).eq("username", msg.username);
        document.querySelectorAll("#messages li").forEach(liItem => {
          const el = liItem.querySelector(".username");
          if (el && el.textContent === msg.username) el.textContent = newName;
        });
        log(`üîÅ Changed username ${msg.username} ‚Üí ${newName}`, null, "info", "admin");
      } catch (e) {
        log("‚ùå Failed to change name", e, "error", "admin");
      }
    };
    adminDiv.appendChild(nameBtn);

    // Toggle Block (by IP)
    const blockBtn = document.createElement("button");
    blockBtn.textContent = "Toggle Block";
    blockBtn.onclick = async () => {
      if (!msg.ip || msg.ip === "unknown") {
        alert("Cannot block: user IP unknown.");
        return;
      }

      try {
        const { data: existing } = await supabase
          .from("blocked_ips")
          .select("*")
          .eq("ip", msg.ip)
          .maybeSingle();

        if (existing) {
          await supabase.from("blocked_ips").delete().eq("ip", msg.ip);
          alert(`${msg.username}'s IP (${msg.ip}) is now unblocked`);
          log(`üîì Unblocked IP ${msg.ip} for ${msg.username}`, null, "warn", "admin");
        } else {
          await supabase.from("blocked_ips").insert({ ip: msg.ip, username: msg.username });
          alert(`${msg.username}'s IP (${msg.ip}) is now blocked`);
          log(`üîí Blocked IP ${msg.ip} for ${msg.username}`, null, "warn", "admin");
        }
      } catch (e) {
        log("‚ùå Failed toggling IP block", e, "error", "admin");
      }
    };
    adminDiv.appendChild(blockBtn);

    // Force Logout
    const logoutBtn = document.createElement("button");
    logoutBtn.textContent = "Force Logout";
    logoutBtn.onclick = async () => {
      if (msg.username === username) {
        alert("You cannot force logout yourself.");
        return;
      }
      try {
        await supabase.from("users").update({ forceLogout: true }).eq("username", msg.username);
        alert(`${msg.username} has been forced to log out.`);
        log(`üîå Forced logout for ${msg.username}`, null, "warn", "admin");
      } catch (e) {
        log("‚ùå Failed to force logout", e, "error", "admin");
      }
    };
    adminDiv.appendChild(logoutBtn);

    // Mute
    const muteBtn = document.createElement("button");
    muteBtn.textContent = "Mute 5min";
    muteBtn.onclick = () => {
      const mutedUsers = (window.__mutedUsers = window.__mutedUsers || {});
      mutedUsers[msg.username] = Date.now() + 5 * 60 * 1000;
      alert(`${msg.username} muted for 5 minutes`);
      log(`üîá Muted ${msg.username} for 5 minutes`, null, "info", "admin");
    };
    adminDiv.appendChild(muteBtn);

    // Export Chat
    const exportBtn = document.createElement("button");
    exportBtn.textContent = "Export Chat";
    exportBtn.onclick = () => {
      const data = Array.from(messagesList.querySelectorAll("li")).map(liItem => ({
        username: liItem.querySelector(".username")?.textContent || "",
        content: liItem.querySelector(".content")?.textContent || "",
        timestamp: liItem.querySelector(".timestamp")?.textContent || ""
      }));
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = "chat.json";
      a.click();
      log("üì¶ Exported chat to chat.json", null, "info", "admin");
    };
    adminDiv.appendChild(exportBtn);

    // Mass delete by keyword
    const massDelBtn = document.createElement("button");
    massDelBtn.textContent = "Delete by Keyword";
    massDelBtn.onclick = async () => {
      const keyword = prompt("Enter keyword to delete:");
      if (!keyword) return;
      try {
        // skip pinned messages when deleting
        const pinned = JSON.parse(localStorage.getItem("pinnedMessages") || "[]");
        const { data } = await supabase.from("messages").select("*");
        const idsToDelete = (data || [])
          .filter(m => String(m.content || "").includes(keyword) && !pinned.includes(m.id))
          .map(m => m.id);
        if (idsToDelete.length) {
          await supabase.from("messages").delete().in("id", idsToDelete);
        }
        Array.from(messagesList.querySelectorAll("li")).forEach(liItem => {
          if ((liItem.querySelector(".content")?.textContent || "").includes(keyword) && liItem.dataset.pinned !== "true")
            liItem.remove();
        });
        log(`üßπ Deleted messages containing "${keyword}" (skipped pinned)`, null, "warn", "admin");
      } catch (e) {
        log("‚ùå Mass delete failed", e, "error", "admin");
      }
    };
    adminDiv.appendChild(massDelBtn);

    // Delete User & Messages (NUKE)
    const nukeBtn = document.createElement("button");
    nukeBtn.textContent = "Delete User & Messages";
    nukeBtn.onclick = async () => {
      if (!confirm(`Are you sure you want to delete ${msg.username} and ALL their messages? This cannot be undone.`))
        return;
      try {
        await supabase.from("messages").delete().eq("username", msg.username);
        const delUser = await supabase.from("users").delete().eq("username", msg.username);
        if (delUser.error)
          log("‚ö†Ô∏è Could not delete user row", delUser.error, "warn", "admin");
        document.querySelectorAll("#messages li").forEach(liItem => {
          if (liItem.querySelector(".username")?.textContent === msg.username)
            liItem.remove();
        });
        alert(`${msg.username} and all their messages have been deleted.`);
        log(`üóë Deleted all messages by ${msg.username}`, null, "warn", "admin");
      } catch (err) {
        log("‚ùå Failed to delete user and messages", err, "error", "admin");
        alert("Error deleting user and messages. See log.");
      }
    };
    adminDiv.appendChild(nukeBtn);

    // User Info
    const infoBtn = document.createElement("button");
    infoBtn.textContent = "User Info";
    infoBtn.onclick = () => {
      alert(
        `Username: ${msg.username}\nIP: ${msg.ip}\nMessage ID: ${msg.id}\nRole: ${msg.role || "User"}`
      );
      log(`‚ÑπÔ∏è Shown info for ${msg.username}`, null, "debug", "admin");
    };
    adminDiv.appendChild(infoBtn);

    // Promote ‚Üí Manager
    const promoteBtn = document.createElement("button");
    promoteBtn.textContent = "Promote ‚Üí Manager";
    promoteBtn.onclick = async () => {
      try {
        await supabase.from("users").upsert({ username: msg.username, role: "Manager" });
        log(`üëë Promoted ${msg.username} to Manager`, null, "info", "admin");
        await loadMessages();
      } catch (e) {
        log("‚ùå Promote failed", e, "error", "admin");
      }
    };
    adminDiv.appendChild(promoteBtn);

    // Promote ‚Üí Admin
    const promoteAdminBtn = document.createElement("button");
    promoteAdminBtn.textContent = "Promote ‚Üí Admin";
    promoteAdminBtn.onclick = async () => {
      try {
        await supabase.from("users").upsert({ username: msg.username, role: "Admin" });
        log(`üëë Promoted ${msg.username} to Admin`, null, "info", "admin");
        await loadMessages();
      } catch (e) {
        log("‚ùå Promote to Admin failed", e, "error", "admin");
      }
    };
    adminDiv.appendChild(promoteAdminBtn);

    // Demote ‚Üí User
    const demoteBtn = document.createElement("button");
    demoteBtn.textContent = "Demote ‚Üí User";
    demoteBtn.onclick = async () => {
      try {
        await supabase.from("users").upsert({ username: msg.username, role: "User" });
        log(`üîª Demoted ${msg.username} to User`, null, "info", "admin");
        await loadMessages();
      } catch (e) {
        log("‚ùå Demote failed", e, "error", "admin");
      }
    };
    adminDiv.appendChild(demoteBtn);
  }

  // --- PIN / UNPIN (available to Admins) ---
  // Pin / Unpin button
  const pinBtn = document.createElement("button");
  pinBtn.textContent = li.dataset.pinned === "true" ? "Unpin" : "Pin";

  // Ensure there is an originalIndex dataset value if not already set
  if (!li.dataset.originalIndex) {
    li.dataset.originalIndex = Array.from(messagesList.children).indexOf(li);
    if (li.dataset.originalIndex === -1) li.dataset.originalIndex = messagesList.children.length;
  }

  // If pin state persisted in localStorage and this li is pinned, mark accordingly
  const pinnedMessagesInitial = JSON.parse(localStorage.getItem("pinnedMessages") || "[]");
  if (pinnedMessagesInitial.includes(msg.id)) {
    li.dataset.pinned = "true";
    li.style.border = "2px solid red";
    pinBtn.textContent = "Unpin";
  }

  pinBtn.onclick = () => {
    const isPinned = li.dataset.pinned === "true";
    let pinnedMessages = JSON.parse(localStorage.getItem("pinnedMessages") || "[]");

    if (!isPinned) {
      // Pin: move to top and style
      messagesList.insertBefore(li, messagesList.firstChild);
      li.style.border = "2px solid red";
      li.dataset.pinned = "true";
      pinBtn.textContent = "Unpin";

      if (!pinnedMessages.includes(msg.id)) pinnedMessages.push(msg.id);
      localStorage.setItem("pinnedMessages", JSON.stringify(pinnedMessages));

      log(`üìå Pinned message id=${msg.id}`, null, "info", "admin");
    } else {
      // Unpin: restore original position based on li.dataset.originalIndex
      const children = Array.from(messagesList.children).filter(c => c !== li);
      const origIdx = parseInt(li.dataset.originalIndex || "0", 10);
      if (origIdx >= children.length) {
        messagesList.appendChild(li);
      } else {
        messagesList.insertBefore(li, children[origIdx]);
      }
      li.style.border = "";
      li.dataset.pinned = "false";
      pinBtn.textContent = "Pin";

      pinnedMessages = pinnedMessages.filter(id => id !== msg.id);
      localStorage.setItem("pinnedMessages", JSON.stringify(pinnedMessages));

      log(`‚ùå Unpinned message id=${msg.id}`, null, "info", "admin");
    }
  };
  adminDiv.appendChild(pinBtn);

  // --- MANAGER: limited controls (delete own message, report) ---
  if (viewerRole === "Manager") {
    if (msg.username === username) {
      const delBtn = document.createElement("button");
      delBtn.textContent = "Delete My Message";
      delBtn.onclick = async () => {
        try {
          await supabase.from("messages").delete().eq("id", msg.id);
          li.remove();
          log(`üóë Deleted own message id=${msg.id}`, null, "warn", "manager");
        } catch (e) {
          log("‚ùå Failed to delete own message", e, "error", "manager");
        }
      };
      adminDiv.appendChild(delBtn);
    }

    const reportBtn = document.createElement("button");
    reportBtn.textContent = "Report Message";
    reportBtn.onclick = async () => {
      try {
        const payload = {
          to: "frenchwizz@proton.me",
          subject: `üö® Message Reported by Manager: ${username}`,
          text: `Reporter (manager): ${username}\nReported user: ${msg.username}\nMessage ID: ${msg.id}\nIP: ${
            msg.ip || "unknown"
          }\n\nMessage content:\n${msg.content || ""}`
        };
        const res = await supabase.functions.invoke("sendEmail", { body: payload });
        if (res.error) {
          const errMsg = res.error.message || JSON.stringify(res.error);
          log("‚ùå sendEmail function error", res.error, "error", "manager");
          alert("Failed to report message:\n" + errMsg);
        } else {
          alert("Message reported successfully!");
        }
      } catch (e) {
        log("‚ùå Failed to report message", e, "error", "manager");
      }
    };
    adminDiv.appendChild(reportBtn);
  }

  // Toggle visibility when message clicked
  li.addEventListener("click", e => {
    e.stopPropagation();
    adminDiv.style.display = adminDiv.style.display === "none" ? "flex" : "none";
  });
  document.addEventListener("click", () => {
    adminDiv.style.display = "none";
  });
}

/* ----------------------------------------------------------------------
   Shortcut: Ctrl+Shift+Alt+T to sign out (clear saved username)
   ---------------------------------------------------------------------- */
document.addEventListener("keydown", (e)=>{
  if(e.ctrlKey && e.shiftKey && e.altKey && e.key.toLowerCase() === "t"){
    e.preventDefault();
    localStorage.removeItem("chatUsername");
    localStorage.removeItem("chatRole");
    location.reload();
  }
});

/* ----------------------------------------------------------------------
   Try to fetch IP (best-effort)
   ---------------------------------------------------------------------- */
fetch("https://api.ipify.org?format=json").then(r=>r.json()).then(d=>{ userIp = d.ip; log("‚úÖ IP: "+userIp, null, "info", "network"); }).catch(()=>{ userIp = "unknown"; log("‚ùå Failed to get IP", null, "warn", "network"); });

/* ----------------------------------------------------------------------
   Small safety: if someone had "takeo" prefilled (old check)
   ---------------------------------------------------------------------- */
if (username && username.toLowerCase() === "takeo") {
  alert("You're not the admin!");
}
</script>

<script>
  (() => {
    function deepSearch(node = document.documentElement) {
      const results = [];
      if (!node) return results;
      const all = Array.from(node.querySelectorAll('*'));
      for (const el of all) {
        try {
          const id = (el.id || '').toLowerCase();
          const cls = (el.className || '').toString().toLowerCase();
          const styles = getComputedStyle(el);
          if (
            id.includes('blocksi') ||
            cls.includes('blocksi') ||
            Number(styles.zIndex) > 10000 ||
            (styles.position === 'fixed' &&
             styles.bottom !== 'auto' &&
             styles.right !== 'auto' &&
             el.offsetWidth < 200)
          ) results.push(el);
          if (el.shadowRoot) results.push(...deepSearch(el.shadowRoot));
        } catch {}
      }
      return results;
    }
  
    function autoHide() {
      const els = deepSearch();
      els.forEach(el => el.style.setProperty('display', 'none', 'important'));
    }
  
    // run immediately and then every half-second
    autoHide();
    setInterval(autoHide, 500);
  })();
</script>
<!-- DEBUG & SAFER saveName() KIT - paste this right after the supabase script tag -->
<script>
console.log("DEBUG KIT: starting checks...");

// 1) Basic runtime checks
try {
  if (!window.supabase) {
    console.error("DEBUG: window.supabase is missing ‚Äî CDN did not load or was blocked.");
  } else if (!window.supabase.createClient) {
    console.error("DEBUG: supabase.createClient missing ‚Äî wrong version?");
  } else {
    console.log("DEBUG: Supabase client factory present.");
  }
} catch (e) {
  console.error("DEBUG: error checking supabase:", e);
}

// 2) Quick supabase create-client test (no side-effects)
let _testSup = null;
try {
  _testSup = window.supabase ? window.supabase.createClient("https://qjajtkdchvapthnidtwj.supabase.co", "anon") : null;
  console.log("DEBUG: created test supabase client (no requests yet).");
} catch(e) {
  console.error("DEBUG: creating supabase client failed:", e);
}

// 3) Test fetching messages (safe, read-only). This shows exact response in console.
(async function testFetch(){
  if(!_testSup){
    console.warn("DEBUG: skipping fetch test because supabase client unavailable.");
    return;
  }
  try {
    console.log("DEBUG: attempting simple select(*) from messages...");
    const resp = await _testSup.from("messages").select().limit(5);
    console.log("DEBUG: select response:", resp);
    if(resp.error) console.error("DEBUG: select returned error:", resp.error);
    else console.log("DEBUG: select returned rows:", resp.data && resp.data.length);
  } catch(e) {
    console.error("DEBUG: exception during test fetch:", e);
  }
})();

// 4) Defensive saveName wiring & implementation
(function wireSaveNameSafely(){
  // ensure elements exist
  const nameInput = document.getElementById("nameInput");
  const saveBtn = document.getElementById("saveNameButton");
  if(!nameInput || !saveBtn) { console.warn("DEBUG: nameInput or saveNameButton not found"); return; }

  // attach a robust handler that always persists locally and logs db action
  async function saferSaveName(e){
    e && e.preventDefault && e.preventDefault();
    const val = (nameInput.value || "").trim();
    if(!val) { alert("Name required!"); return; }

    console.log("DEBUG: saferSaveName called with:", val);
    // persist locally immediately (guarantee UI unlock)
    try {
      localStorage.setItem("chatUsername", val);
      // default role while we fetch
      localStorage.setItem("chatRole", "User");
    } catch(err) {
      console.warn("DEBUG: unable to write localStorage:", err);
    }

    // try to create/fetch user in DB but do not block UI on failure
    try {
      const sup = window.supabase && window.supabase.createClient ? window.supabase.createClient("https://qjajtkdchvapthnidtwj.supabase.co", "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InFqYWp0a2RjaHZhcHRobmlkdHdqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTgyMTI4MDgsImV4cCI6MjA3Mzc4ODgwOH0.BYyhualVRAOqctt8u3flAH9PHKaAV8bedV8JeaYjf7M") : null;
      if(!sup) { console.warn("DEBUG: supabase client unavailable for DB create/fetch"); return; }
      // try select
      const { data, error } = await sup.from("users").select("username,role").eq("username", val).maybeSingle();
      console.log("DEBUG: users.select result:", {data, error});
      if (error) {
        // try upsert
        console.warn("DEBUG: select had error, attempting upsert...", error);
        const up = await sup.from("users").upsert({ username: val, role: "User" }).select();
        console.log("DEBUG: upsert result:", up);
        if(up.error) console.error("DEBUG: upsert error:", up.error);
        if(up.data && up.data[0] && up.data[0].role) {
          localStorage.setItem("chatRole", up.data[0].role);
        }
      } else if (data && data.role) {
        localStorage.setItem("chatRole", data.role);
      }
    } catch(err) {
      console.error("DEBUG: DB fetch/upsert threw:", err);
    }

    // finally unlock UI so user isn't stuck
    try {
      document.getElementById("namePrompt").style.display = "none";
      document.getElementById("messageInput").disabled = false;
      document.getElementById("sendButton").disabled = false;
      console.log("DEBUG: UI unlocked after saving name locally.");
      // optionally trigger your loadMessages if defined
      if (typeof loadMessages === "function") {
        try { loadMessages(); } catch(e){ console.error("DEBUG: loadMessages() threw:", e); }
      }
    } catch(err) {
      console.error("DEBUG: unlocking UI failed:", err);
    }
  }

  // remove previous handlers then attach ours
  saveBtn.replaceWith(saveBtn.cloneNode(true));
  const newBtn = document.getElementById("saveNameButton");
  newBtn.addEventListener("click", saferSaveName);
  // also allow Enter on input to save
  nameInput.addEventListener("keydown", (ev)=>{ if(ev.key === "Enter"){ ev.preventDefault(); saferSaveName(); } });

  console.log("DEBUG: saferSaveName wired to Save Name button.");
})();
</script>

</body>
</html>
